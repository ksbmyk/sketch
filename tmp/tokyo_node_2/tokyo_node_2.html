<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>詩とコンピュータ - 季節のコード詩（高解像度対応版）</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: white;
            font-family: 'Courier New', monospace;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        #controls {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        h2 {
            color: #0ff;
            margin: 0 0 20px 0;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 15px 0;
        }
        .info-box {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid #0ff;
        }
        .info-box span {
            color: #0ff;
            font-weight: bold;
        }
        .export-status {
            background: rgba(255,0,0,0.2);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }
        .export-status.active {
            display: block;
            background: rgba(0,255,0,0.2);
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        #canvasContainer {
            display: flex;
            justify-content: center;
            background: #000;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="controls">
            <h2>🌸 詩とコンピュータ - 季節のコード詩（高解像度対応版）</h2>
            
            <div class="info-grid">
                <div class="info-box">
                    <div>プレビューモード: <span id="previewModeText" style="color: #ff0;">Google Form用</span></div>
                    <div style="font-size: 12px; color: #888;">Mキーで切り替え</div>
                </div>
                <div class="info-box">
                    <div>作品サイズ: <span id="workSizeText">960×1620</span></div>
                    <div style="font-size: 12px; color: #888;">実際の解像度</div>
                </div>
                <div class="info-box">
                    <div>FPS: <span id="fps">60</span></div>
                    <div style="font-size: 12px; color: #888;">現在の季節: <span id="currentSeason">春</span></div>
                </div>
            </div>
            
            <div class="export-status" id="exportStatus">
                <div>📸 高解像度書き出し中...</div>
                <div>フレーム: <span id="exportFrame">0</span> / <span id="totalFrames">900</span></div>
                <div style="font-size: 12px; color: #aaa;">処理には時間がかかります</div>
            </div>
            
            <div class="button-group">
                <button onclick="togglePreviewMode()">🔄 モード切替 (Google/NEORT)</button>
                <button onclick="exportHighResGoogle()" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);">📸 Google Form用 高解像度書き出し</button>
                <button onclick="exportHighResNeort()" style="background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);">📸 NEORT用 高解像度書き出し</button>
                <button onclick="toggleGuide()">📐 ガイド表示</button>
                <button onclick="resetAnimation()">🔄 リセット</button>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,0,0.1); border: 1px solid #444; border-radius: 5px;">
                <div style="color: #ffa500; font-size: 12px; margin-bottom: 5px;">📌 操作方法</div>
                <div style="font-size: 11px; color: #aaa; line-height: 1.4;">
                    <strong>M:</strong> プレビューモード切替（Google ⇔ NEORT）<br>
                    <strong>S:</strong> 現在のフレーム保存（プレビューサイズ）<br>
                    <strong>高解像度書き出し:</strong> 上のボタンで各モード用の実サイズで書き出し<br>
                    <strong>R:</strong> アニメーションリセット | <strong>G:</strong> ガイド表示切替<br>
                    <strong>保存先:</strong> ブラウザのダウンロードフォルダ
                </div>
            </div>
        </div>
        
        <div id="canvasContainer"></div>
    </div>

<script>
// ===============================================
// 設定値
// ===============================================
const WORK_SCALE = 0.25; // プレビュー用スケール（25%）

// Google Form用
const GOOGLE_CANVAS_W = 3840;   // Google Form用のキャンバス幅
const GOOGLE_CANVAS_H = 2160;   // Google Form用のキャンバス高さ
const GOOGLE_WORK_W = 960;      // Google Form用の作品幅
const GOOGLE_WORK_H = 1620;     // Google Form用の作品高さ

// NEORT用
const NEORT_W = 2160;           // NEORT用の幅
const NEORT_H = 3840;           // NEORT用の高さ

// プレビューモード
let previewMode = 'google'; // 'google' or 'neort'

// プレビュー用サイズ（モードによって動的に変更）
let previewW, previewH, workW, workH;

// ガイド表示
let showGuide = true;

// 高解像度書き出し用
let exportGraphics = null;
let isExporting = false;
let exportFrameCount = 0;
let exportMode = '';

// ===============================================
// 季節のコード詩の変数
// ===============================================
let d; // データ定義
let f = []; // 降ってくる要素の配列
let l = 0.0; // lerp用のカウンター
let s; // 季節の配列
let cs; // 現在の季節
let ns; // 次の季節
let seasonStartTime;
let frameCounter = 0;
let generationPhase = 0;
const SEASON_DURATION = 3750; // 各季節の長さ（ミリ秒）

// 高解像度書き出し用の変数
let exportFlakes = []; // 書き出し用の要素配列
let exportGenerationPhase = 0;

// ===============================================
// p5.js メイン
// ===============================================
function setup() {
    // ピクセル密度を1に固定（Retinaディスプレイ対策）
    pixelDensity(1);
    
    // 初期モード設定
    previewMode = 'google';
    updateCanvasSize();
    
    let canvas = createCanvas(previewW, previewH);
    canvas.parent('canvasContainer');
    
    // 季節データの初期化
    initSeasonData();
    seasonStartTime = millis();
    generateFlakes();
}

function updateCanvasSize() {
    if (previewMode === 'google') {
        // Google Form用: 3840×2160の25%、作品は960×1620
        previewW = 960;
        previewH = 540;
        workW = GOOGLE_WORK_W * WORK_SCALE;  // 240
        workH = GOOGLE_WORK_H * WORK_SCALE;  // 405
    } else {
        // NEORT用: 2160×3840の25% = 540×960（作品が全画面）
        previewW = NEORT_W * WORK_SCALE;  // 540
        previewH = NEORT_H * WORK_SCALE;  // 960
        workW = previewW;  // 540（全画面）
        workH = previewH;  // 960（全画面）
    }
}

function initSeasonData() {
    // モードに応じたサイズスケール
    let sizeScale;
    if (isExporting) {
        // 高解像度書き出し時は実サイズ
        sizeScale = exportMode === 'google' ? 4 : 9;
    } else {
        // プレビュー時は縮小
        sizeScale = previewMode === 'google' ? 1 : 2.25;
    }
    
    // データ定義（季節の詩的表現）
    d = {
        s: { // 春（Spring）- 花
            c: '✿',
            r: true,
            s: 12 * sizeScale,  
            co: [255, 105, 180],
            bg: [255, 182, 193],
            code: "春.tender('✿', :bloom)",
            name: "春"
        },
        u: { // 夏（Summer）- セミコロン（水滴のメタファー）
            c: ';',
            r: false,
            s: 10 * sizeScale,  
            co: [30, 144, 255],
            bg: [135, 206, 250],
            code: "夏.sudden(';', :pour)",
            name: "夏"
        },
        a: { // 秋（Autumn）- スペード（落葉のメタファー）
            c: '♠',
            r: true,
            s: 11 * sizeScale,  
            co: [204, 85, 0],
            bg: [204, 163, 0],
            code: "秋.gradual('♠', :fall)",
            name: "秋"
        },
        w: { // 冬（Winter）- 雪の結晶
            c: '*',
            r: false,
            s: 15 * sizeScale,  
            co: [255, 255, 255],
            bg: [0, 31, 63],
            code: "冬.silent('*', :float)",
            name: "冬"
        }
    };
    
    s = ['s', 'u', 'a', 'w'];
    cs = 's';  // 現在の季節：春
    ns = 'u';  // 次の季節：夏
}

function draw() {
    if (isExporting) {
        // 高解像度書き出しモード
        drawHighResFrame();
        return;
    }
    
    // 通常のプレビュー描画
    background(0);
    
    // モードに応じた配置
    push();
    if (previewMode === 'google') {
        translate(0, 0);
    } else {
        translate(0, 0);
    }
    
    // 作品の描画
    drawPoetryWork();
    
    pop();
    
    // Google Form用の場合のみ、作品エリア外を黒でマスク
    if (previewMode === 'google') {
        fill(0);
        noStroke();
        rect(GOOGLE_WORK_W * WORK_SCALE, 0, previewW, previewH);  // 右側全体
        rect(0, GOOGLE_WORK_H * WORK_SCALE, GOOGLE_WORK_W * WORK_SCALE, previewH);  // 左下部分
    }
    
    // ガイドの表示
    if (showGuide) {
        drawGuides();
    }
    
    // FPS表示（書き出し中は更新しない）
    if (frameCount % 10 === 0) {
        updateUI();
    }
    
    frameCounter++;
}

function drawPoetryWork() {
    push();
    
    // 背景の更新
    updateBackground();
    
    // 季節の遷移処理
    handleTransition();
    
    // 段階的生成の処理
    if (generationPhase < 3) {
        generateFlakesPhase();
    }
    
    // 季節のコード詩を表示
    displayPoetryCode();
    
    // 降る要素の描画
    renderFlakes();
    
    pop();
}

// 高解像度フレームの描画
function drawHighResFrame() {
    if (!exportGraphics) return;
    
    exportGraphics.clear();
    
    if (exportMode === 'google') {
        // Google Form用：3840×2160の黒背景
        exportGraphics.background(0);
        
        // 左上に960×1620の作品を配置
        exportGraphics.push();
        
        // クリッピング領域を設定（作品エリアのみ）
        exportGraphics.drawingContext.save();
        exportGraphics.drawingContext.beginPath();
        exportGraphics.drawingContext.rect(0, 0, GOOGLE_WORK_W, GOOGLE_WORK_H);
        exportGraphics.drawingContext.clip();
        
        // 実サイズで作品を描画
        workW = GOOGLE_WORK_W;
        workH = GOOGLE_WORK_H;
        drawPoetryWorkHighRes(exportGraphics);
        
        // クリッピングを解除
        exportGraphics.drawingContext.restore();
        exportGraphics.pop();
        
        // 作品エリア外を確実に黒でマスク（念のため）
        exportGraphics.fill(0);
        exportGraphics.noStroke();
        // 右側全体
        exportGraphics.rect(GOOGLE_WORK_W, 0, GOOGLE_CANVAS_W - GOOGLE_WORK_W, GOOGLE_CANVAS_H);
        // 下側部分
        exportGraphics.rect(0, GOOGLE_WORK_H, GOOGLE_WORK_W, GOOGLE_CANVAS_H - GOOGLE_WORK_H);
    } else {
        // NEORT用：2160×3840全体
        workW = NEORT_W;
        workH = NEORT_H;
        drawPoetryWorkHighRes(exportGraphics);
    }
    
    // フレームを保存
    exportGraphics.save(`${exportMode}_frame_${nf(exportFrameCount, 4)}.png`);
    
    exportFrameCount++;
    
    // 書き出し進捗を更新
    document.getElementById('exportFrame').textContent = exportFrameCount;
    
    // 900フレーム（15秒分）完了したら終了
    if (exportFrameCount >= 900) {
        stopExport();
    }
    
    // frameCounterは増やさない（書き出し中は通常のアニメーションを停止）
}

// 高解像度用の作品描画
function drawPoetryWorkHighRes(pg) {
    pg.push();
    
    // フレームベースで季節を決定
    let totalProgress = (exportFrameCount % 900) / 900.0;  // 0.0 ~ 1.0（15秒ループ）
    let seasonIndex = Math.floor(totalProgress * 4);  // 0, 1, 2, 3
    let seasonProgress = (totalProgress * 4) % 1;  // 各季節内での進行度
    
    // 現在の季節を設定
    let currentSeason = s[seasonIndex % 4];
    let nextSeason = s[(seasonIndex + 1) % 4];
    
    // 背景の描画
    drawExportBackground(pg, currentSeason, nextSeason, seasonProgress);
    
    // 要素生成（段階的）
    generateExportFlakesPhase(currentSeason, seasonIndex);
    
    // コード詩を表示
    displayExportPoetryCode(pg, currentSeason);
    
    // 降る要素の描画
    renderExportFlakes(pg);
    
    pg.pop();
}

// 書き出し用背景描画
function drawExportBackground(pg, currentSeason, nextSeason, seasonProgress) {
    let currentBg = color(...d[currentSeason].bg);
    let nextBg = color(...d[nextSeason].bg);
    
    let lerpAmount = seasonProgress < 0.5 ? 0 : map(seasonProgress, 0.5, 1, 0, 1);
    let bg = lerpColor(currentBg, nextBg, lerpAmount);
    
    pg.fill(bg);
    pg.noStroke();
    pg.rect(0, 0, workW, workH);
}

// 書き出し用要素生成
function generateExportFlakesPhase(currentSeason, seasonIndex) {
    let frameInSeason = exportFrameCount % 225;  // 各季節は225フレーム
    
    // 実サイズに合わせた初期位置調整
    let posScale = exportMode === 'google' ? 1 : 2.25;
    
    // 各季節の開始時（0フレーム目）で第1波を生成
    if (frameInSeason === 0) {
        exportFlakes = [];  // 前の季節の要素をクリア
        // 第1波：即座に50個（画面外も含めて広範囲に生成）
        for (let i = 0; i < 50; i++) {
            exportFlakes.push(new ExportFlake(
                random(-200, workW + 200),  // 左右に大きく余裕を持たせて生成
                random(-320 * posScale, -20 * posScale),  // 画面上部から開始
                d[currentSeason].c,
                d[currentSeason].co,
                random(d[currentSeason].s * 0.8, d[currentSeason].s * 1.2),
                d[currentSeason].r,
                exportFrameCount
            ));
        }
    }
    
    // 0.4秒後（24フレーム目）で第2波
    if (frameInSeason === 24) {
        for (let i = 0; i < 30; i++) {
            exportFlakes.push(new ExportFlake(
                random(-200, workW + 200),  // 左右に大きく余裕を持たせて生成
                random(-240 * posScale, -20 * posScale),
                d[currentSeason].c,
                d[currentSeason].co,
                random(d[currentSeason].s * 0.7, d[currentSeason].s * 1.1),
                d[currentSeason].r,
                exportFrameCount
            ));
        }
    }
    
    // 0.8秒後（48フレーム目）で第3波
    if (frameInSeason === 48) {
        for (let i = 0; i < 20; i++) {
            exportFlakes.push(new ExportFlake(
                random(-200, workW + 200),  // 左右に大きく余裕を持たせて生成
                random(-160 * posScale, -20 * posScale),
                d[currentSeason].c,
                d[currentSeason].co,
                random(d[currentSeason].s * 0.6, d[currentSeason].s * 1.0),
                d[currentSeason].r,
                exportFrameCount
            ));
        }
    }
}

// 書き出し用コード詩表示
function displayExportPoetryCode(pg, currentSeason) {
    pg.push();
    // 実サイズに合わせたテキストサイズ
    let sizeScale = exportMode === 'google' ? 1 : 2.25;
    
    pg.fill(255, 255, 255, 100);
    pg.textSize(32 * sizeScale);  // 実サイズ用に調整
    pg.textAlign(CENTER, CENTER);
    pg.textFont('monospace');
    pg.text(d[currentSeason].code, workW/2, workH/2);
    
    pg.textSize(20 * sizeScale);  // 実サイズ用に調整
    pg.fill(255, 255, 255, 60);
    pg.text("#Computer_Poetry_TOKYO_NODE", workW/2, workH/2 + 60 * sizeScale);
    pg.pop();
}

// 書き出し用要素描画
function renderExportFlakes(pg) {
    exportFlakes = exportFlakes.filter(flake => {
        flake.updateExport(exportFrameCount);
        flake.displayExport(pg);
        return !flake.isOffscreenExport();
    });
}

// 書き出し用Flakeクラス（プレビューと完全に同じ動作にする）
class ExportFlake {
    constructor(x, y, char, col, size, rotate, birthFrame) {
        this.x = x;  // 制限なし
        this.y = y;
        this.char = char;
        this.col = col;
        this.size = size;
        this.shouldRotate = rotate;
        this.rotation = rotate ? random(TWO_PI) : 0;
        this.birthFrame = birthFrame;
        
        // プレビューと同じ速度計算に修正
        let speedScale = exportMode === 'google' ? 4 : 9;  // プレビューと同じ比率
        
        let speedGroup = random();
        if (speedGroup < 0.3) {
            this.speed = random(2.5, 3.5) * speedScale;  // プレビューと同じ
        } else if (speedGroup < 0.7) {
            this.speed = random(3.5, 4.5) * speedScale;  // プレビューと同じ
        } else {
            this.speed = random(4.5, 6) * speedScale;  // プレビューと同じ
        }
        
        this.initialSpeed = this.speed;
        this.velocity = rotate ? random(-0.5, 0.5) * speedScale : 0;  // プレビューと同じ範囲
        this.opacity = 255;
        this.baseOpacity = random(180, 255);
        this.wobblePhase = random(TWO_PI);
    }
    
    updateExport(currentFrame) {
        let framesSinceBirth = currentFrame - this.birthFrame;
        
        // プレビューと同じ動き
        this.speed = this.initialSpeed * Math.pow(1.002, framesSinceBirth);
        this.y += this.speed;
        this.x += this.velocity;
        
        // 横揺れもプレビューと同じ
        this.x += sin(framesSinceBirth * 0.01 + this.wobblePhase) * 0.15;
        
        // 境界チェックなし - 自然に画面外へ
        
        if (this.shouldRotate) {
            this.rotation += 0.03;
        }
        
        // フェードアウト
        if (this.y > workH * 0.7) {
            this.opacity = map(this.y, workH * 0.7, workH, this.baseOpacity, 0);
        } else {
            this.opacity = this.baseOpacity;
        }
    }
    
    displayExport(pg) {
        // 画面外でも描画（クリッピングに任せる）
        pg.push();
        pg.translate(this.x, this.y);
        pg.rotate(this.rotation);
        pg.fill(this.col[0], this.col[1], this.col[2], this.opacity);
        pg.textSize(this.size);
        pg.textFont('monospace');
        pg.textAlign(CENTER, CENTER);
        pg.text(this.char, 0, 0);
        pg.pop();
    }
    
    isOffscreenExport() {
        // プレビューと同じ判定
        return this.y > workH + 20;
    }
}

function updateBackground() {
    let elapsed = millis() - seasonStartTime;
    l = min(elapsed / SEASON_DURATION, 1.0);
    
    let currentBg = color(...d[cs].bg);
    let nextBg = color(...d[ns].bg);
    
    let lerpAmount = l < 0.5 ? 0 : map(l, 0.5, 1, 0, 1);
    let bg = lerpColor(currentBg, nextBg, lerpAmount);
    
    fill(bg);
    noStroke();
    rect(0, 0, workW, workH);
}

function handleTransition() {
    if (l >= 1) {
        cs = ns;
        let currentIndex = s.indexOf(cs);
        let nextIndex = (currentIndex + 1) % 4;
        ns = s[nextIndex];
        
        seasonStartTime = millis();
        l = 0;
        f = [];
        generateFlakes();
    }
}

function generateFlakes() {
    generationPhase = 0;
    generateFlakesPhase();
}

function generateFlakesPhase() {
    let elapsed = millis() - seasonStartTime;
    
    let posScale = isExporting ? 
        (exportMode === 'google' ? 4 : 9) : 
        (previewMode === 'google' ? 1 : 2.25);
    
    if (generationPhase === 0) {
        for (let i = 0; i < 50; i++) {
            f.push(new Flake(
                random(-20, workW + 20),  // 画面外も含めて生成
                random(-80 * posScale, -5 * posScale),
                d[cs].c,
                d[cs].co,
                random(d[cs].s * 0.8, d[cs].s * 1.2),
                d[cs].r
            ));
        }
        generationPhase = 1;
    } else if (generationPhase === 1 && elapsed > 400) {
        for (let i = 0; i < 30; i++) {
            f.push(new Flake(
                random(-20, workW + 20),  // 画面外も含めて生成
                random(-60 * posScale, -5 * posScale),
                d[cs].c,
                d[cs].co,
                random(d[cs].s * 0.7, d[cs].s * 1.1),
                d[cs].r
            ));
        }
        generationPhase = 2;
    } else if (generationPhase === 2 && elapsed > 800) {
        for (let i = 0; i < 20; i++) {
            f.push(new Flake(
                random(-20, workW + 20),  // 画面外も含めて生成
                random(-40 * posScale, -5 * posScale),
                d[cs].c,
                d[cs].co,
                random(d[cs].s * 0.6, d[cs].s * 1.0),
                d[cs].r
            ));
        }
        generationPhase = 3;
    }
}

function displayPoetryCode() {
    push();
    let sizeScale = previewMode === 'google' ? 1 : 2.25;
    
    fill(255, 255, 255, 100);
    textSize(8 * sizeScale);
    textAlign(CENTER, CENTER);
    textFont('monospace');
    text(d[cs].code, workW/2, workH/2);
    
    textSize(5 * sizeScale);
    fill(255, 255, 255, 60);
    text("#Computer_Poetry_TOKYO_NODE", workW/2, workH/2 + 15 * sizeScale);
    pop();
}

function renderFlakes() {
    f = f.filter(flake => {
        flake.update();
        flake.display();
        return !flake.isOffscreen();
    });
}

class Flake {
    constructor(x, y, char, col, size, rotate) {
        this.x = x;  // 制限なし
        this.y = y;
        this.char = char;
        this.col = col;
        this.size = size;
        this.shouldRotate = rotate;
        this.rotation = rotate ? random(TWO_PI) : 0;
        
        let speedScale = isExporting ? 
            (exportMode === 'google' ? 4 : 9) : 
            (previewMode === 'google' ? 1 : 2.25);
        
        let speedGroup = random();
        if (speedGroup < 0.3) {
            this.speed = random(2.5, 3.5) * speedScale;
        } else if (speedGroup < 0.7) {
            this.speed = random(3.5, 4.5) * speedScale;
        } else {
            this.speed = random(4.5, 6) * speedScale;
        }
        
        this.velocity = rotate ? random(-0.5, 0.5) * speedScale : 0;
        this.opacity = 255;
        this.baseOpacity = random(180, 255);
    }
    
    update() {
        this.speed *= 1.002;
        this.y += this.speed;
        this.x += this.velocity;
        
        // 横の動きに波を加える
        this.x += sin(frameCounter * 0.01 + this.y * 0.01) * 0.15;
        
        // 境界チェックなし - 自然に画面外へ
        
        if (this.shouldRotate) {
            this.rotation += 0.03;
        }
        
        if (this.y > workH * 0.7) {
            this.opacity = map(this.y, workH * 0.7, workH, this.baseOpacity, 0);
        } else {
            this.opacity = this.baseOpacity;
        }
    }
    
    display() {
        push();
        translate(this.x, this.y);
        rotate(this.rotation);
        fill(this.col[0], this.col[1], this.col[2], this.opacity);
        textSize(this.size);
        textFont('monospace');
        textAlign(CENTER, CENTER);
        text(this.char, 0, 0);
        pop();
    }
    
    displayHighRes(pg) {
        pg.push();
        pg.translate(this.x, this.y);
        pg.rotate(this.rotation);
        pg.fill(this.col[0], this.col[1], this.col[2], this.opacity);
        pg.textSize(this.size);
        pg.textFont('monospace');
        pg.textAlign(CENTER, CENTER);
        pg.text(this.char, 0, 0);
        pg.pop();
    }
    
    isOffscreen() {
        return this.y > workH + 20;
    }
}

function drawGuides() {
    push();
    
    stroke(0, 255, 255, 100);
    strokeWeight(1);
    noFill();
    
    if (previewMode === 'google') {
        rect(0, 0, GOOGLE_WORK_W * WORK_SCALE, GOOGLE_WORK_H * WORK_SCALE);
    } else {
        rect(0, 0, workW, workH);
    }
    
    stroke(255, 0, 255, 50);
    line(previewW / 2, 0, previewW / 2, previewH);
    line(0, previewH / 2, previewW, previewH / 2);
    
    fill(0, 255, 255);
    noStroke();
    textSize(10);
    textAlign(LEFT, TOP);
    
    if (previewMode === 'google') {
        text(`作品: ${GOOGLE_WORK_W}×${GOOGLE_WORK_H}`, 5, GOOGLE_WORK_H * WORK_SCALE + 5);
        text(`キャンバス: ${GOOGLE_CANVAS_W}×${GOOGLE_CANVAS_H}`, 5, GOOGLE_WORK_H * WORK_SCALE + 20);
        text('左上配置 (Google Form用)', 5, GOOGLE_WORK_H * WORK_SCALE + 35);
    } else {
        text(`作品: ${NEORT_W}×${NEORT_H}`, 5, 5);
        text('全画面 (NEORT用)', 5, 20);
        text('余白なし', 5, 35);
    }
    
    pop();
}

function updateUI() {
    document.getElementById('fps').textContent = Math.round(frameRate());
    document.getElementById('currentSeason').textContent = d[cs].name;
    
    let modeElement = document.getElementById('previewModeText');
    if (modeElement) {
        modeElement.textContent = previewMode === 'google' ? 'Google Form用' : 'NEORT用';
    }
    
    let sizeElement = document.getElementById('workSizeText');
    if (sizeElement) {
        if (previewMode === 'google') {
            sizeElement.textContent = `${GOOGLE_WORK_W}×${GOOGLE_WORK_H}`;
        } else {
            sizeElement.textContent = `${NEORT_W}×${NEORT_H}`;
        }
    }
}

// ===============================================
// 高解像度書き出し関数
// ===============================================
function exportHighResGoogle() {
    if (isExporting) {
        console.log('すでに書き出し中です');
        return;
    }
    
    console.log('Google Form用 高解像度書き出し開始...');
    console.log('出力サイズ: 3840×2160（左上に960×1620の作品）');
    
    // 書き出し設定
    exportMode = 'google';
    isExporting = true;
    exportFrameCount = 0;
    exportFlakes = [];  // 書き出し用要素を初期化
    exportGenerationPhase = 0;
    
    // 高解像度グラフィックスを作成
    exportGraphics = createGraphics(GOOGLE_CANVAS_W, GOOGLE_CANVAS_H);
    exportGraphics.pixelDensity(1);  // ピクセル密度を1に固定
    
    // UIを更新
    document.getElementById('exportStatus').classList.add('active');
    document.getElementById('totalFrames').textContent = '900';
    
    // 季節データを再初期化（高解像度用）
    initSeasonData();
}

function exportHighResNeort() {
    if (isExporting) {
        console.log('すでに書き出し中です');
        return;
    }
    
    console.log('NEORT用 高解像度書き出し開始...');
    console.log('出力サイズ: 2160×3840');
    
    // 書き出し設定
    exportMode = 'neort';
    isExporting = true;
    exportFrameCount = 0;
    exportFlakes = [];  // 書き出し用要素を初期化
    exportGenerationPhase = 0;
    
    // 高解像度グラフィックスを作成
    exportGraphics = createGraphics(NEORT_W, NEORT_H);
    exportGraphics.pixelDensity(1);  // ピクセル密度を1に固定
    
    // UIを更新
    document.getElementById('exportStatus').classList.add('active');
    document.getElementById('totalFrames').textContent = '900';
    
    // 季節データを再初期化（高解像度用）
    initSeasonData();
}

function stopExport() {
    isExporting = false;
    exportGraphics.remove();
    exportGraphics = null;
    exportFlakes = [];  // 書き出し用要素をクリア
    exportGenerationPhase = 0;
    
    // UIを更新
    document.getElementById('exportStatus').classList.remove('active');
    
    // プレビューモードに戻す
    initSeasonData();
    updateCanvasSize();
    
    console.log(`書き出し完了：${exportFrameCount}フレーム`);
    alert(`高解像度書き出し完了！\n${exportFrameCount}枚の画像がダウンロードフォルダに保存されました。\n\n動画化コマンド：\nffmpeg -r 60 -i ${exportMode}_frame_%04d.png -c:v libx264 -pix_fmt yuv420p -crf 18 ${exportMode}_output.mp4`);
}

// ===============================================
// 操作関数
// ===============================================
function togglePreviewMode() {
    previewMode = previewMode === 'google' ? 'neort' : 'google';
    updateCanvasSize();
    resizeCanvas(previewW, previewH);
    
    initSeasonData();
    
    console.log('プレビューモードを切り替えました：', previewMode === 'google' ? 'Google Form用' : 'NEORT用');
    updateUI();
}

function toggleGuide() {
    showGuide = !showGuide;
}

function resetAnimation() {
    frameCounter = 0;
    l = 0;
    cs = 's';
    ns = 'u';
    f = [];
    generationPhase = 0;
    seasonStartTime = millis();
    generateFlakes();
}

// キーボードショートカット
function keyPressed() {
    if (key === 'm' || key === 'M') {
        togglePreviewMode();
    } else if (key === 'g' || key === 'G') {
        toggleGuide();
    } else if (key === 'r' || key === 'R') {
        resetAnimation();
    } else if (key === 's' || key === 'S') {
        // プレビューサイズで保存
        let prefix = previewMode === 'google' ? 'google_preview_' : 'neort_preview_';
        saveCanvas(prefix + 'poetry_computer_' + frameCount, 'png');
        console.log('プレビュー画像を保存しました');
    }
}
</script>
</body>
</html>
