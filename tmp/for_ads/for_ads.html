<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <meta charset="utf-8" />
    <title>広告募集中</title>
  </head>
  <body>
    <div>
        <div>
            <div>
                <script>
let circles = [];
let words = ["広", "告", "募", "集", "中"];
let particles = [];

function setup() {
  // createCanvas(windowWidth, windowHeight);

  createCanvas(2237/2, 1080/2);

  let totalWidth = words.length * 50 + random(30, 100) * (words.length - 1); // 玉の総幅
  let startX = (width - totalWidth) / 2; // 画面中央からスタート位置を計算

  for (let i = 0; i < words.length; i++) {
    let speedY = random(1, 3);  // 初期速度をランダムに設定
    let xPos = startX + i * (50 + random(30, 100)); // 文字ごとにX位置を更新

    circles.push({
      word: words[i],
      x: xPos,
      y: random(50, height / 2),
      diameter: 50,
      speedX: 0,
      speedY: speedY,
      baseColor: color(50, 150, 255)
    });
  }
  
  for (let i = 0; i < 200; i++) {
    particles.push(new Particle(random(width), random(height)));
  }
}

function draw() {
  let c1 = color(20, 30, 80);
  let c2 = color(0, 20, 40);
  setGradient(0, 0, width, height, c1, c2, 1);


  for (let i = 0; i < particles.length; i++) {
    particles[i].update();
    particles[i].show();
  }


  for (let i = 0; i < circles.length; i++) {
    let circle = circles[i];

    circle.y += circle.speedY;




    // 上下の端で反発
    if (circle.y - circle.diameter / 2 < 0 || circle.y + circle.diameter / 2 > height) {
      circle.speedY *= -1; // 速度反転
    }
    changeCircleColor(circle);
    // 円を描画
    fill(circle.baseColor);
    noStroke();
    ellipse(circle.x, circle.y, circle.diameter);

    // 文字を描画
    fill(255);
    textSize(32);
    textAlign(CENTER, CENTER);
    text(circle.word, circle.x, circle.y);
  }
}

function setGradient(x, y, w, h, c1, c2, axis) {
  noFill();
  if (axis == 1) { // 垂直グラデーション
    for (let i = y; i <= y + h; i++) {
      let inter = map(i, y, y + h, 0, 1);
      let c = lerpColor(c1, c2, inter);
      stroke(c);
      line(x, i, x + w, i);
    }
  } else { // 水平グラデーション
    for (let i = x; i <= x + w; i++) {
      let inter = map(i, x, x + w, 0, 1);
      let c = lerpColor(c1, c2, inter);
      stroke(c);
      line(i, y, i, y + h);
    }
  }
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = random(5, 15);
    this.speedX = random(-0.5, 0.5);
    this.speedY = random(-0.5, 0.5);
    this.alpha = random(50, 255); // 透明度
  }

  update() {
    this.x += this.speedX;
    this.y += this.speedY;

    // 画面外に出たら戻す
    if (this.x > width || this.x < 0) {
      this.speedX *= -1;
    }
    if (this.y > height || this.y < 0) {
      this.speedY *= -1;
    }
  }

  show() {
    fill(255, this.alpha);
    noStroke();
    ellipse(this.x, this.y, this.size);
  }
}

// 玉の色を動的に変更
function changeCircleColor(circle) {
  let ratio = map(circle.y, 0, height, 0, 1);
  let r = lerp(100, 44, ratio);
  let g = lerp(160, 62, ratio);
  let b = lerp(255, 80, ratio);
  circle.baseColor = color(r, g, b);
}

                </script>        
            </div>
        </div>    
    </div>
  </body>
</html>

